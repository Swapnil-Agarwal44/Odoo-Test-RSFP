from odoo import fields, models, api # type: ignore
import logging

# This file is used to ensure that the custom sequence is generated by default if the new lot is created, irrespective of the interface used 

_logger = logging.getLogger(__name__)

class StockMoveLine(models.Model):
    _inherit = 'stock.move.line'

    @api.model
    def default_get(self, fields_list):
        """Override to provide default lot when creating move lines"""
        _logger.info("=== STOCK MOVE LINE DEFAULT_GET CALLED ===")
        _logger.info(f"Context: {self._context}")
        
        res = super(StockMoveLine, self).default_get(fields_list)
        _logger.info(f"Super result: {res}")
        
        # Check if we should generate a lot name
        if 'lot_name' in fields_list:
            product_id = self._context.get('default_product_id') or res.get('product_id')
            _logger.info(f"Product ID: {product_id}")
            
            if product_id:
                product = self.env['product.product'].browse(product_id)
                _logger.info(f"Product: {product.name}, Tracking: {product.tracking}")
                
                # Only generate for products with lot/serial tracking
                if product.tracking in ['lot', 'serial']:
                    custom_lot_name = self._generate_lot_name_for_product(product_id)
                    _logger.info(f"Generated lot name: {custom_lot_name}")
                    
                    if custom_lot_name:
                        res['lot_name'] = custom_lot_name
                        _logger.info(f"Set lot_name to: {custom_lot_name}")
        
        _logger.info(f"Final result: {res}")
        return res
    

    # NEW: Override write method to handle existing records
    def write(self, vals):
        """Override write to set lot_name for existing records that don't have it"""
        for record in self:
            # Check if this is an existing record without lot_name but with product_id
            if (not record.lot_name and 
                record.product_id and 
                record.product_id.tracking in ['lot', 'serial'] and 
                record.qty_done == 0 and  # Not yet processed
                not vals.get('lot_name')):  # Not setting lot_name in this write
                
                _logger.info(f"Auto-generating lot_name for existing record: {record.id}")
                custom_lot_name = self._generate_lot_name_for_product(record.product_id.id)
                if custom_lot_name:
                    vals['lot_name'] = custom_lot_name
                    _logger.info(f"Auto-set lot_name to: {custom_lot_name}")
        
        return super(StockMoveLine, self).write(vals)

    @api.model
    def create(self, vals):
        """Override create to ensure lot_name is set for new records"""
        _logger.info("=== STOCK MOVE LINE CREATE CALLED ===")
        _logger.info(f"Values: {vals}")
        
        # If lot_name not provided but product_id is available
        if (not vals.get('lot_name') and 
            vals.get('product_id')):
            
            product = self.env['product.product'].browse(vals['product_id'])
            if product.tracking in ['lot', 'serial']:
                custom_lot_name = self._generate_lot_name_for_product(vals['product_id'])
                if custom_lot_name:
                    vals['lot_name'] = custom_lot_name
                    _logger.info(f"Set lot_name in create: {custom_lot_name}")
        
        return super(StockMoveLine, self).create(vals)


    @api.model
    def _generate_lot_name_for_product(self, product_id):
        """Generate lot name using the same logic as stock.lot"""
        _logger.info(f"=== Generating lot name for product: {product_id} ===")
        
        if not product_id:
            return False
            
        product = self.env['product.product'].browse(product_id)
        if not product.exists():
            return False
        
        abbreviation = product.product_tmpl_id.lot_abbreviation or 'XX'
        today = fields.Date.today()
        date_str = today.strftime('%d%m%y')
        
        # Get the next sequence number
        sequence_code = 'parent.lot.daily.sequence'
        seq_number = self.env['ir.sequence'].next_by_code(sequence_code)
        
        if not seq_number:
            _logger.error("Sequence not found!")
            return f"{abbreviation}-{date_str}-ERROR"
        
        lot_name = f"{abbreviation}-{date_str}-{seq_number}"
        _logger.info(f"Generated lot name: {lot_name}")
        return lot_name

    @api.onchange('product_id')
    def _onchange_product_id_lot_name(self):
        """Generate lot name when product changes"""
        _logger.info(f"=== MOVE LINE ONCHANGE product_id ===")
        _logger.info(f"Product: {self.product_id.name if self.product_id else 'None'}")
        _logger.info(f"Current lot_name: {self.lot_name}")
        
        if self.product_id and self.product_id.tracking in ['lot', 'serial']:
            # Only set if lot_name is empty or looks like a default value
            if not self.lot_name or self.lot_name.startswith('SN'):
                generated_name = self._generate_lot_name_for_product(self.product_id.id)
                _logger.info(f"Generated name via onchange: {generated_name}")
                if generated_name:
                    self.lot_name = generated_name
                    _logger.info(f"Set lot_name to: {self.lot_name}")


    # NEW: Method to fix existing records without lot_name
    def action_generate_missing_lot_names(self):
        """Action to generate lot names for records that are missing them"""
        for record in self:
            if (not record.lot_name and 
                record.product_id and 
                record.product_id.tracking in ['lot', 'serial'] and
                record.state in ['draft', 'waiting', 'confirmed', 'assigned']):
                
                custom_lot_name = record._generate_lot_name_for_product(record.product_id.id)
                if custom_lot_name:
                    record.lot_name = custom_lot_name
                    _logger.info(f"Fixed lot_name for record {record.id}: {custom_lot_name}")







    # def _action_done(self):
    #     """Override to capture arrived quantity when receiving"""
    #     res = super(StockMoveLine, self)._action_done()
        
    #     # For each move line with a lot, update arrived_quantity if not set
    #     for move_line in self:
    #         if (move_line.lot_id and 
    #             not move_line.lot_id.arrived_quantity and 
    #             move_line.qty_done > 0 and
    #             move_line.location_dest_id.usage == 'internal' and
    #             move_line.location_id.usage in ['supplier', 'production']):
                
    #             # This is the first receipt of this lot
    #             move_line.lot_id.set_arrived_quantity(move_line.qty_done)
                
    #     return res

    # def write(self, vals):
    #     """Override write to capture quantity when lot is assigned to existing move line"""
    #     # Before calling super, check if we're setting a lot_id with qty_done
    #     for record in self:
    #         if (vals.get('lot_id') and 
    #             (vals.get('qty_done', 0) > 0 or record.qty_done > 0) and
    #             record.location_dest_id and record.location_dest_id.usage == 'internal' and
    #             record.location_id and record.location_id.usage in ['supplier', 'production']):
                
    #             # Get the lot being assigned
    #             lot = self.env['stock.lot'].browse(vals['lot_id']) if vals.get('lot_id') else record.lot_id
    #             qty = vals.get('qty_done', record.qty_done)
                
    #             if lot and not lot.arrived_quantity and qty > 0:
    #                 lot.set_arrived_quantity(qty)

    #     return super(StockMoveLine, self).write(vals)

    # @api.model
    # def create(self, vals):
    #     """Override create to capture arrived quantity for new move lines"""
    #     move_line = super(StockMoveLine, self).create(vals)
        
    #     # Check if this is a receiving move line with a lot
    #     if (move_line.lot_id and 
    #         move_line.qty_done > 0 and
    #         move_line.location_dest_id.usage == 'internal' and
    #         move_line.location_id.usage in ['supplier', 'production']):
            
    #         if not move_line.lot_id.arrived_quantity:
    #             move_line.lot_id.set_arrived_quantity(move_line.qty_done)
        
    #     return move_line