from odoo import fields, models, api # type: ignore
import logging

# This file is used to ensure that the custom sequence is generated by default if the new lot is created, irrespective of the interface used 

_logger = logging.getLogger(__name__)

class StockMoveLine(models.Model):
    _inherit = 'stock.move.line'

    @api.model
    def default_get(self, fields_list):
        """Override to provide default lot when creating move lines"""
        _logger.info("=== STOCK MOVE LINE DEFAULT_GET CALLED ===")
        _logger.info(f"Context: {self._context}")
        
        res = super(StockMoveLine, self).default_get(fields_list)
        _logger.info(f"Super result: {res}")
        
        # Check if we should generate a lot name
        if 'lot_name' in fields_list:
            product_id = self._context.get('default_product_id') or res.get('product_id')
            _logger.info(f"Product ID: {product_id}")
            
            if product_id:
                product = self.env['product.product'].browse(product_id)
                _logger.info(f"Product: {product.name}, Tracking: {product.tracking}")
                
                # Only generate for products with lot/serial tracking
                if product.tracking in ['lot', 'serial']:
                    custom_lot_name = self._generate_lot_name_for_product(product_id)
                    _logger.info(f"Generated lot name: {custom_lot_name}")
                    
                    if custom_lot_name:
                        res['lot_name'] = custom_lot_name
                        _logger.info(f"Set lot_name to: {custom_lot_name}")
        
        _logger.info(f"Final result: {res}")
        return res
    

    # NEW: Override write method to handle existing records
    def write(self, vals):
        """Override write to set lot_name for existing records that don't have it"""
        for record in self:
            # Check if this is an existing record without lot_name but with product_id
            if (not record.lot_name and 
                record.product_id and 
                record.product_id.tracking in ['lot', 'serial'] and 
                record.qty_done == 0 and  # Not yet processed
                not vals.get('lot_name')):  # Not setting lot_name in this write
                
                _logger.info(f"Auto-generating lot_name for existing record: {record.id}")
                custom_lot_name = self._generate_lot_name_for_product(record.product_id.id)
                if custom_lot_name:
                    vals['lot_name'] = custom_lot_name
                    _logger.info(f"Auto-set lot_name to: {custom_lot_name}")
        
        return super(StockMoveLine, self).write(vals)

    @api.model
    def create(self, vals):
        """Override create to ensure lot_name is set for new records"""
        _logger.info("=== STOCK MOVE LINE CREATE CALLED ===")
        _logger.info(f"Values: {vals}")
        
        # If lot_name not provided but product_id is available
        if (not vals.get('lot_name') and 
            vals.get('product_id')):
            
            product = self.env['product.product'].browse(vals['product_id'])
            if product.tracking in ['lot', 'serial']:
                custom_lot_name = self._generate_lot_name_for_product(vals['product_id'])
                if custom_lot_name:
                    vals['lot_name'] = custom_lot_name
                    _logger.info(f"Set lot_name in create: {custom_lot_name}")
        
        return super(StockMoveLine, self).create(vals)


    @api.model
    def _generate_lot_name_for_product(self, product_id):
        """Generate lot name using the same logic as stock.lot"""
        _logger.info(f"=== Generating lot name for product: {product_id} ===")
        
        if not product_id:
            return False
            
        product = self.env['product.product'].browse(product_id)
        if not product.exists():
            return False
        
        abbreviation = product.product_tmpl_id.lot_abbreviation or 'XX'
        today = fields.Date.today()
        date_str = today.strftime('%d%m%y')
        
        # Get the next sequence number
        sequence_code = 'parent.lot.daily.sequence'
        seq_number = self.env['ir.sequence'].next_by_code(sequence_code)
        
        if not seq_number:
            _logger.error("Sequence not found!")
            return f"{abbreviation}-{date_str}-ERROR"
        
        lot_name = f"{abbreviation}-{date_str}-{seq_number}"
        _logger.info(f"Generated lot name: {lot_name}")
        return lot_name

    @api.onchange('product_id')
    def _onchange_product_id_lot_name(self):
        """Generate lot name when product changes"""
        _logger.info(f"=== MOVE LINE ONCHANGE product_id ===")
        _logger.info(f"Product: {self.product_id.name if self.product_id else 'None'}")
        _logger.info(f"Current lot_name: {self.lot_name}")
        
        if self.product_id and self.product_id.tracking in ['lot', 'serial']:
            # Only set if lot_name is empty or looks like a default value
            if not self.lot_name or self.lot_name.startswith('SN'):
                generated_name = self._generate_lot_name_for_product(self.product_id.id)
                _logger.info(f"Generated name via onchange: {generated_name}")
                if generated_name:
                    self.lot_name = generated_name
                    _logger.info(f"Set lot_name to: {self.lot_name}")


    # NEW: Method to fix existing records without lot_name
    def action_generate_missing_lot_names(self):
        """Action to generate lot names for records that are missing them"""
        for record in self:
            if (not record.lot_name and 
                record.product_id and 
                record.product_id.tracking in ['lot', 'serial'] and
                record.state in ['draft', 'waiting', 'confirmed', 'assigned']):
                
                custom_lot_name = record._generate_lot_name_for_product(record.product_id.id)
                if custom_lot_name:
                    record.lot_name = custom_lot_name
                    _logger.info(f"Fixed lot_name for record {record.id}: {custom_lot_name}")